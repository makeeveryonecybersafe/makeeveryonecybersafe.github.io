<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TheDrill Simulation</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
:root {
  /* MECS Palette */
  --bg-color: #0b0b0b;
  --panel-bg: #141414;
  --text-primary: #f0f0f0;
  --text-dim: #888888;
  --accent-red: #ff2a2a;
  --accent-blue: #00d2ff;
  --accent-warn: #ffaa00;
  --accent-success: #00ff66;
  
  --font-stack: 'Consolas', 'Monaco', 'Courier New', monospace;
  --glass-border: 1px solid rgba(255, 255, 255, 0.1);
}

* { box-sizing: border-box; }

body {
  background-color: var(--bg-color);
  color: var(--text-primary);
  font-family: var(--font-stack);
  margin: 0;
  height: 100vh;
  width: 100vw;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
}

.window {
  width: 100%;
  height: 100%;
  max-width: 1400px;
  background: var(--panel-bg);
  display: flex;
  flex-direction: column;
  position: relative;
  box-shadow: 0 0 50px rgba(0,0,0,0.8);
}

@media (min-width: 800px) {
  .window {
    width: 90%;
    height: 90vh;
    border: var(--glass-border);
    border-left: 4px solid var(--accent-red);
  }
}

/* --- HUD --- */
.header {
  padding: 15px 20px;
  background: linear-gradient(90deg, #1a1a1a 0%, #0b0b0b 100%);
  border-bottom: 1px solid #333;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
}

.header-title {
  font-size: 14px;
  font-weight: 700;
  letter-spacing: 2px;
  text-transform: uppercase;
}
.header-title span { color: var(--accent-red); }

.threat-container {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 12px;
  color: var(--accent-red);
}

.threat-bar-bg {
  width: 100px;
  height: 6px;
  background: #333;
  position: relative;
}

.threat-bar-fill {
  height: 100%;
  background: var(--accent-red);
  width: 0%;
  transition: width 0.3s ease;
}

/* --- TERMINAL --- */
.terminal {
  flex: 1;
  padding: 20px;
  overflow-y: auto;
  font-size: 14px;
  line-height: 1.5;
  padding-bottom: 60px;
}
.terminal::-webkit-scrollbar { width: 6px; }
.terminal::-webkit-scrollbar-track { background: #111; }
.terminal::-webkit-scrollbar-thumb { background: #333; }

/* --- OUTPUT CLASSES --- */
.output { margin-bottom: 4px; word-wrap: break-word; }
.prompt-text { color: var(--accent-red); font-weight: bold; }
.dir { color: var(--accent-blue); font-weight: bold; }
.file { color: var(--text-primary); }
.sys { color: var(--text-dim); }
.error { color: var(--accent-red); }
.success { color: var(--accent-success); }
.warning { color: var(--accent-warn); }
.info { color: var(--text-dim); border-left: 2px solid #333; padding-left: 10px; }
.help-table { color: #ccc; margin-top: 10px; margin-bottom: 10px; }
.help-cmd { color: var(--accent-blue); font-weight: bold; width: 120px; display: inline-block; }
.game-over { color: var(--accent-red); font-size: 1.2em; font-weight: bold; border: 1px solid var(--accent-red); padding: 20px; text-align: center; margin: 20px 0; background: rgba(255, 42, 42, 0.1); }

/* --- INPUT --- */
.input-line { display: flex; align-items: center; margin-top: 10px; }
input {
  background: transparent;
  border: none;
  color: #fff;
  font-family: inherit;
  font-size: 16px;
  flex: 1;
  outline: none;
  caret-color: var(--accent-red);
  padding-left: 10px;
}

/* --- MOBILE BAR --- */
.mobile-bar {
  display: none;
  height: 50px;
  background: #111;
  border-top: 1px solid #333;
  overflow-x: auto;
  align-items: center;
  padding: 0 10px;
  gap: 8px;
  flex-shrink: 0;
}
.mobile-btn {
  background: #222;
  border: 1px solid #333;
  color: #aaa;
  padding: 8px 14px;
  font-size: 12px;
  font-family: inherit;
  cursor: pointer;
  white-space: nowrap;
  font-weight: bold;
}
.mobile-btn:active { background: var(--accent-red); color: #fff; }

@media (max-width: 768px) {
  .mobile-bar { display: flex; }
  .terminal { font-size: 13px; padding: 15px; }
}

/* --- FX --- */
.scanline {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
  background-size: 100% 2px, 3px 100%;
  pointer-events: none; z-index: 10; opacity: 0.5;
}
.overlay-red {
  position: absolute; top:0; left:0; width:100%; height:100%;
  background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.2) 100%);
  pointer-events: none; display: none; z-index: 5;
}
</style>
</head>
<body>

<div class="window">
  <div class="scanline"></div>
  <div class="overlay-red" id="alert-overlay"></div>
  
  <div class="header">
    <div class="header-title">THE<span>DRILL</span> v4.1</div>
    <div class="threat-container">
      TRACE
      <div class="threat-bar-bg"><div class="threat-bar-fill" id="threat-bar"></div></div>
      <span id="threat-text">0%</span>
    </div>
  </div>

  <div class="terminal" id="term" onclick="focusInput()"></div>

  <div class="mobile-bar">
    <button class="mobile-btn" onclick="quickCmd('ls -la')">LS</button>
    <button class="mobile-btn" onclick="quickCmd('cd ..')">BACK</button>
    <button class="mobile-btn" onclick="quickCmd('cat ')">CAT</button>
    <button class="mobile-btn" onclick="quickCmd('scan')">SCAN</button>
    <button class="mobile-btn" onclick="quickCmd('submit ')">SUBMIT</button>
    <button class="mobile-btn" onclick="quickCmd('help')">HELP</button>
  </div>
</div>

<script>
/* ================= ENGINE CORE ================= */
const term = document.getElementById("term");
const threatBar = document.getElementById("threat-bar");
const threatText = document.getElementById("threat-text");
const alertOverlay = document.getElementById("alert-overlay");

let state = {
  cwd: "/",
  keys: ["BOOTSTRAP"],
  chain: [],
  trace: 0,
  active: true,
  maxEvidence: 4,
  scenario: null
};

let currentInput = null;

// --- UTILS ---
function print(txt, cls="") {
  const d = document.createElement("div");
  d.className = "output " + cls;
  d.innerHTML = txt.replace(/\n/g, '<br>');
  term.insertBefore(d, currentInput ? currentInput.parentNode : null);
  term.scrollTop = term.scrollHeight;
}

function xorCrypt(text, key) {
  return btoa([...text].map((c,i)=>String.fromCharCode(c.charCodeAt(0)^key.charCodeAt(i%key.length))).join(""));
}

function xorDecrypt(enc, key) {
  try {
    const raw = atob(enc);
    return [...raw].map((c,i)=>String.fromCharCode(c.charCodeAt(0)^key.charCodeAt(i%key.length))).join("");
  } catch { return null; }
}

function updateTrace(amount) {
  if (!state.active) return;
  state.trace = Math.min(100, Math.max(0, state.trace + amount));
  threatBar.style.width = state.trace + "%";
  threatText.innerText = state.trace + "%";
  
  if (state.trace > 70) alertOverlay.style.display = "block";
  else alertOverlay.style.display = "none";

  if (state.trace >= 100) triggerEnding("DETECTED");
}

/* ================= SCENARIO GENERATOR ================= */
function createScenarios() {
  const seed = Math.random().toString(36).slice(2,8).toUpperCase();
  const c = [
    `EV-${seed}-A`, `EV-${seed}-B`, `EV-${seed}-C`, `FINAL-${seed}`
  ];

  return {
    "LATERAL": {
      name: "LATERAL MOVEMENT",
      desc: "Suspicious SSH activity detected. Track the attacker moving between nodes.",
      chain: c,
      startHint: "/var/log/auth.log",
      ips: ["192.168.1.50", "192.168.1.101", "c2.attacker.com"],
      fs: {
        "/var/log/auth.log": xorCrypt(`Failed root login from 192.168.1.50\nAccepted publickey for user1\nFragment: ${c[0]}`, "BOOTSTRAP"),
        "/home/user1/.bash_history": "ssh svcacct@192.168.1.101\nscp /tmp/tool.sh svcacct@192.168.1.101:/tmp",
        "/var/lib/dhcp/leases": xorCrypt(`lease 192.168.1.101 { hardware ethernet 00:0c:29:4f:8e:32; client-hostname "DB-ADMIN"; Note: ${c[1]} }`, c[0]),
        "/home/svcacct/notes.txt": xorCrypt(`DB-ADMIN Credentials moved to backup server.\nRef: ${c[2]}`, c[1]),
        "/opt/backup/config.yaml": xorCrypt(`upstream: c2.attacker.com\nmode: exfil\nID: ${c[3]}`, c[2])
      }
    },
    "RANSOM": {
      name: "RANSOMWARE ATTACK",
      desc: "Users reporting encrypted files. Find the entry point and the decryptor key.",
      chain: c,
      startHint: "/var/mail/root",
      ips: ["10.0.0.5", "1BitcoinAddress..."],
      fs: {
        "/var/mail/root": xorCrypt(`Subject: URGENT INVOICE\nAttachment: invoice_2024.js\n(The attachment was executed by www-data)\nTrace: ${c[0]}`, "BOOTSTRAP"),
        "/var/www/html/invoice_2024.js": "eval(String.fromCharCode(10,32,44...)) // Obfuscated Dropper",
        "/var/www/html/uploads/payload.bin": xorCrypt(`[BINARY BLOB]\nRansom Note generated at /home/user/Desktop\nKey fragment: ${c[1]}`, c[0]),
        "/home/user/Desktop/READ_ME.txt": xorCrypt(`YOUR FILES ARE ENCRYPTED.\nPayment address: 1BitcoinAddress...\nRef ID: ${c[2]}`, c[1]),
        "/tmp/ram_dump.mem": xorCrypt(`...memory string search...\nAES_KEY FOUND: ${c[3]}`, c[2])
      }
    },
    "INSIDER": {
      name: "INSIDER THREAT",
      desc: "Sensitive design docs leaked. Investigate internal developer activity.",
      chain: c,
      startHint: "/opt/git/log",
      ips: ["internal-printer-99", "usb-device-002"],
      fs: {
        "/opt/git/log": xorCrypt(`Commit: 'Fixed typo' by dev_mike\nTimestamp: 3:00 AM (Anomaly)\nDiff shows hidden data: ${c[0]}`, "BOOTSTRAP"),
        "/home/dev_mike/projects/steg.py": "import steganography\n# hiding blueprints inside cat pictures",
        "/home/dev_mike/Pictures/cat.jpg": xorCrypt(`[JPEG HEADER]\nSteganography payload detected.\nExtracted: ${c[1]}`, c[0]),
        "/var/spool/printer/job_99.log": xorCrypt(`Print Job: 'Resignation_Letter.pdf'\nUser: dev_mike\nMetadata: ${c[2]}`, c[1]),
        "/media/usb/hidden_volume": xorCrypt(`MOUNTED VOLUME\nContains: Company_Secrets.zip\nProof: ${c[3]}`, c[2])
      }
    }
  };
}

function initFS(scenarioKey) {
  const s = createScenarios()[scenarioKey];
  state.scenario = s;
  state.chain = s.chain;
  
  // Base FS Structure
  const fs = {
    "/": { "etc": "DIR", "var": "DIR", "home": "DIR", "opt": "DIR", "tmp": "DIR", "media": "DIR" },
    "/etc": { "passwd": "root:x:0:0::/root:/bin/bash", "hosts": "127.0.0.1 localhost" },
    "/var": { "log": "DIR", "lib": "DIR", "mail": "DIR", "www": "DIR", "spool": "DIR" },
    "/var/log": { "syslog": "System initialized..." },
    "/var/lib": { "dhcp": "DIR" },
    "/var/www": { "html": "DIR" },
    "/var/www/html": { "index.php": "<?php echo 'Hello'; ?>", "uploads": "DIR" },
    "/var/spool": { "printer": "DIR" },
    "/home": { "user1": "DIR", "svcacct": "DIR", "user": "DIR", "dev_mike": "DIR" },
    "/home/user1": { ".bash_history": "" },
    "/home/svcacct": { "notes.txt": "" },
    "/home/user": { "Desktop": "DIR", "Downloads": "DIR" },
    "/home/dev_mike": { "projects": "DIR", "Pictures": "DIR" },
    "/opt": { "backup": "DIR", "git": "DIR" },
    "/media": { "usb": "DIR" }
  };

  state.fileSystem = fs;
  state.specialFiles = s.fs;
  return s;
}

/* ================= LOGIC & COMMANDS ================= */

function listDir(path) {
  path = path.replace(/\/+$/, "") || "/";
  let contents = new Set();
  
  // Add directories
  Object.keys(state.fileSystem).forEach(k => {
    if (k.startsWith(path) && k !== path) {
      const rel = k.substring(path.length === 1 ? 1 : path.length + 1);
      if (!rel.includes("/")) contents.add(rel + "/");
    }
  });

  // Add scenario files
  Object.keys(state.specialFiles).forEach(k => {
    const dir = k.substring(0, k.lastIndexOf('/'));
    if (dir === path) {
      contents.add(k.substring(k.lastIndexOf('/') + 1));
    }
  });
  
  // Add base files
  let baseObj = state.fileSystem[path];
  if (baseObj && typeof baseObj === 'object') {
     Object.keys(baseObj).forEach(k => {
       if (baseObj[k] === "DIR") contents.add(k + "/");
       else contents.add(k);
     });
  }

  return Array.from(contents).sort();
}

function handleCmd(raw) {
  if (!state.active) return;
  
  const args = raw.trim().split(/\s+/);
  const cmd = args[0].toLowerCase();
  const arg1 = args[1] || "";

  // COST OF DOING BUSINESS
  if(cmd !== "help" && cmd !== "history" && cmd !== "recover") {
    updateTrace(1); 
  }

  // --- REFINED HELP ---
  if (cmd === "help") {
    print("AVAILABLE COMMANDS:", "info");
    const h = [
      ["ls", "List files in current directory"],
      ["cd [dir]", "Navigate directory structure"],
      ["cat [file]", "Read/Decrypt file content"],
      ["submit [id]", "Submit evidence ID to unlock next layer"],
      ["scan", "Network sweep for active connections (+5% Trace)"],
      ["recover", "Attempt to scrub logs and lower Trace (RISKY)"],
      ["history", "Show mission status and keys"],
      ["clear", "Clear terminal screen"]
    ];
    let out = "<div class='help-table'>";
    h.forEach(x => {
      out += `<div><span class='help-cmd'>${x[0]}</span> ${x[1]}</div>`;
    });
    out += "</div>";
    print(out);
    return;
  }
  
  if (cmd === "clear") {
    term.innerHTML = "";
    return;
  }

  if (cmd === "ls") {
    const items = listDir(state.cwd);
    if (items.length === 0) print("(empty)", "info");
    else items.forEach(i => print(i, i.endsWith("/") ? "dir" : "file"));
    return;
  }

  if (cmd === "cd") {
    if (arg1 === "..") {
      state.cwd = state.cwd.split("/").slice(0,-1).join("/") || "/";
    } else {
      const target = (state.cwd === "/" ? "" : state.cwd) + "/" + arg1.replace(/\/$/, "");
      if (listDir(target).length > 0 || state.fileSystem[target]) {
        state.cwd = target;
      } else {
        print(`cd: ${arg1}: No such directory`, "error");
      }
    }
    return;
  }

  if (cmd === "cat") {
    if(!arg1) { print("Usage: cat [filename]", "error"); return; }
    const fullPath = (state.cwd === "/" ? "" : state.cwd) + "/" + arg1;
    let content = state.specialFiles[fullPath];
    
    if (!content) {
      const dirObj = state.fileSystem[state.cwd];
      if (dirObj && dirObj[arg1] && dirObj[arg1] !== "DIR") content = dirObj[arg1];
    }

    if (!content) {
      print(`cat: ${arg1}: No such file`, "error");
      return;
    }

    let decrypted = null;
    for (let k of state.keys) {
      const tryDec = xorDecrypt(content, k);
      if (tryDec && (tryDec.includes("Fragment") || tryDec.includes("Ref") || tryDec.includes("trace") || tryDec.includes(" "))) {
        decrypted = tryDec;
        break;
      }
    }

    if (decrypted) {
      print(decrypted);
      if (decrypted.includes("Fragment") || decrypted.includes("Ref") || decrypted.includes("Proof") || decrypted.includes("Key")) {
        print(">> EVIDENCE DETECTED. SUBMIT ID TO PROCEED.", "success");
      }
    } else {
      if ((content.includes("EV-") || content.includes("FINAL")) && !state.keys.includes(state.keys[state.keys.length-1])) {
        print("[ENCRYPTED] - MISSING PREVIOUS KEY", "warning");
        print("Raw: " + content.substring(0, 20) + "...", "sys");
      } else {
        print(content.length > 50 && !content.includes(" ") ? "[BINARY DATA]" : content);
      }
    }
    return;
  }

  // --- NEW COMMAND: SCAN ---
  if (cmd === "scan") {
    updateTrace(4); // Extra cost
    print("Initiating network sweep...", "sys");
    setTimeout(() => {
        print("Active Connections Found:", "info");
        state.scenario.ips.forEach(ip => {
            print(` -> ${ip} [ESTABLISHED]`, "warning");
        });
        print("Correlate IPs with file system logs.", "sys");
    }, 600);
    return;
  }

  // --- NEW COMMAND: RECOVER ---
  if (cmd === "recover") {
      print("Attempting to scrub system logs...", "sys");
      const chance = Math.random();
      if (chance > 0.4) {
          updateTrace(-15);
          print("Log scrub successful. Trace reduced.", "success");
      } else {
          updateTrace(10);
          print("SCRUB FAILED. Activity flagged by IDS.", "error");
      }
      return;
  }

  if (cmd === "submit") {
    if (state.chain.includes(arg1)) {
      if (!state.keys.includes(arg1)) {
        state.keys.push(arg1);
        updateTrace(-15); // Reward
        print(`[+] KEY ACCEPTED: ${arg1}`, "success");
        print(`[+] DECRYPTION ROUTINE UPDATED`, "success");
        if (arg1.startsWith("FINAL")) triggerEnding("WIN");
      } else {
        print("Key already active.", "info");
      }
    } else {
      print("[-] INVALID KEY. TRACE SPIKE.", "error");
      updateTrace(10);
    }
    return;
  }
  
  if (cmd === "history") {
    print(`OP: ${state.scenario.name}`);
    print(`KEYS: ${state.keys.length - 1} / ${state.maxEvidence}`);
    print(`TRACE: ${state.trace}%`);
    return;
  }

  print("Command not found. Type 'help'.", "error");
}

/* ================= GAME LOOP ================= */

function triggerEnding(type) {
  state.active = false;
  if (type === "WIN") {
    print("----------------------------------------");
    print("COMPROMISE CONTAINED. FLAG CAPTURED.", "success");
    print(`FINAL SCORE: ${100 - state.trace}/100`, "success");
  } else if (type === "DETECTED") {
    print("----------------------------------------");
    print("!!! INTRUSION DETECTED !!!", "game-over");
    print("System wiped by remote attacker.", "error");
  }
  term.innerHTML += "<br><br><button class='mobile-btn' style='width:100%' onclick='location.reload()'>RESTART SIMULATION</button>";
  term.scrollTop = term.scrollHeight;
}

function focusInput() { if(currentInput && state.active) currentInput.focus(); }

function prompt() {
  if (!state.active) return;
  
  const line = document.createElement("div");
  line.className = "input-line";
  line.innerHTML = `<span class='prompt-text'>drill:${state.cwd} #</span>`;
  
  const input = document.createElement("input");
  input.type = "text";
  input.autocomplete = "off";
  input.spellcheck = false;
  
  input.onkeydown = (e) => {
    if (e.key === "Enter") {
      const val = input.value;
      line.innerHTML = `<span class='prompt-text'>drill:${state.cwd} #</span> ${val}`;
      handleCmd(val);
      if (state.active) setTimeout(prompt, 50);
    }
  };

  line.appendChild(input);
  term.appendChild(line);
  currentInput = input;
  input.focus();
  term.scrollTop = term.scrollHeight;
}

function quickCmd(c) {
  if(!currentInput) return;
  if(c.endsWith(' ')) { currentInput.value += c; currentInput.focus(); }
  else { currentInput.value = c; currentInput.dispatchEvent(new KeyboardEvent('keydown',{'key':'Enter'})); }
}

// BOOT
const scenarioKeys = ["LATERAL", "RANSOM", "INSIDER"];
const chosen = scenarioKeys[Math.floor(Math.random() * scenarioKeys.length)];
const sData = initFS(chosen);

print("THE DRILL OS v4.1 [SECURE BOOT]");
print("Loading Modules... OK");
print("------------------------------------------------");
print(`ALERT: ${sData.name}`, "error");
print(`BRIEF: ${sData.desc}`, "info");
print("------------------------------------------------");

prompt();

</script>
</body>
</html>
